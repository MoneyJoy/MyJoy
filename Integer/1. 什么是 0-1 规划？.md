## 1\. 什么是 0-1 规划？

0-1 整数规划是一类特殊的整数规划，变量的取值只能是 0 或 1。

0-1 变量可以描述开关、取舍、有无等逻辑关系、顺序关系，可以处理背包问题、指派问题、选址问题 、计划安排、线路设计 、人员安排等各种决策规划问题。进而，任何整数都可以用二进制表达，整数变量就可以表示为多个 0-1 变量的组合，因此任何整数规划都可以转化为 0-1 规划问题来处理。0-1 规划问题与运筹学中的很多经典问题也都有紧密联系。

在数学建模学习中，0-1 规划主要用于求解互斥的决策问题、互斥的约束条件问题、固定费用问题和分派问题。0-1 规划是数模竞赛的常见题型，国赛 B题经常有 0-1规划问题或可以转化为 0-1 规划问题。

0-1 规划的算法都比较复杂，大规模问题一般没有精确解法。本文仍然使用 PuLP 工具包求解 0-1 规划问题，该工具包的使用比较简单。建议本文读者重点关注 0-1 规划问题的分类及建模方法，把握哪些问题是 0-1 规划问题，是哪一类的 0-1 规划问题，如何对这些典型问题进行建模。在此基础上，才能调用 PuLP 函数进行求解。

* * *

  

## 2\. 0-1 规划的分类及建模方法

规划问题的数学模型包括决策变量、约束条件和目标函数，围绕这三个要素都可能存在互斥的情况，从而导出不同类型的0-1规划问题，其建模方法也有差别。

### 2.1 互斥的决策问题

互斥的决策问题，是指决策方案、计划互斥，如决定投资项目、确定投资场所、选择投产产品等。

例如，双十一的促销活动，淘宝、京东、拼多多要求店铺二选一，最多只能选择参加一家平台，否则可能会被封杀，这是典型的互斥决策问题。

**背包问题**就是经典的互斥决策问题。给定一组 n 个物品，每种物品 i 的价值为 v\_i、重量/体积为 w\_i，背包所能容纳的总重量/总容量为（B），如何选择其中若干种物品（每种物品选 0 个或 1 个），使得物品的总价值最高？

背包问题的建模方法如下：

定义决策变量为：
$$
 x_i = \begin{cases} 
0, & \text{不选择第} i \text{个物品} \\ 
1, & \text{选择第} i \text{个物品} 
\end{cases} 
$$


定义目标函数为：

$$

\max f(x) = \sum_{i=1}^n v_i x_i  
$$

$$
\text{s.t.:} \begin{cases} 
\sum_{i=1}^n w_i x_i \leq B, \\ 
x_i = 0, 1 
\end{cases}
$$



很多应用问题都可以用上述的背包问题数学模型来表达，例如：

+   有 n个项目，每个项目所需投资额为 w\_i，投产后的利润为 v\_i，投资总限额为 B，求利润最大的投资方案；
+   处理器能力有限，任务很多，如何选择使处理器的效用最大；

  

### 2.2 互斥的约束问题

互斥的约束问题，是指具有多个互斥的约束条件，这些约束条件只有一个起作用。

例如，货物运输有车运或者船运两种运输方式可供选择，已知采用车运的约束条件和船运的约束条件，必须且只能选择其中一种运输方式。这两个约束条件互斥，有且只有一个起作用，这是可以引入一个 0-1变量来处理。

一般地，设有 m 个互斥的约束条件：

$ a_{i1}x_1 + \ldots + a_{in}x_n \leq b_i，i = 1, \ldots, m $

该类问题的建模方法，为了保证只有一个约束条件起作用，可以引入一个充分大的常数 M 和 m 个 0-1 变量表示约束是否起作用：

$$
y_i = \begin{cases} 
0, & \text{第 } i \text{ 个约束不起作用} \\ 
1, & \text{第 } i \text{ 个约束起作用} 
\end{cases}
$$


于是可以构造新的 m+1 个约束条件：

$$
\text{s.t.:} \begin{cases} 
a_{i1}x_1 + \ldots + a_{in}x_n \leq b_i + (1 - y_i)M, & i = 1, \ldots, m \\ 
y_1 + \ldots + y_m = 1 \\ 
y_i = 0, 1 
\end{cases}
$$


由于 M 足够大，新的约束条件就能保证只有 y\_i=1 的约束条件起作用，而其它约束条件都不起作用。

  

### 2.3 固定费用问题（Fixed cost problem）

固定费用问题，是指求解生产成本最小问题时，总成本包括固定成本和变动成本，而选择不同生产方式会有不同的固定成本，因此总成本与选择的生产方式有关。

固定费用问题，实际上是互斥的目标函数问题，对于不同的生产方式具有多个互斥的目标函数，但只有一个起作用。固定费用问题不能用一般的线性规划模型求解。

一般地，设有 m 种生产方式可供选择，采用第 j 种方式时的固定成本为 K\_j、变动成本为 c\_j、产量为 x\_j，则采用各种生产方式的总成本分别为：

$$
\min P_j = \begin{cases} 
k_j + c_j x_j, & \text{if } x_j \geq 0 \\ 
0, & \text{if } x_j = 0, \, j = 1, \ldots, m 
\end{cases}
$$


该类问题的建模方法，为了构造统一的目标函数，可以引入 m 个 0-1 变量 y\_j 表示是否采用第 j 种生产方式：

yj\={0，不采用第j种生产方式1，采用第j种生产方式yj\={0，不采用第j种生产方式1，采用第j种生产方式y\_j = \\begin{cases} 0，不采用第\\;j\\;种生产方式\\\\ 1，采用第\\;j\\; 种生产方式 \\end{cases}

于是可以构造新的目标函数和约束条件：

$$
\min f(x) = \sum_{j=1}^m (k_j y_j + c_j x_j)
$$

$$
\text{s.t.:} \; x_j \leq y_j M, \; j = 1, \ldots, m
$$





M 是一个充分大的常数。

  

### 2.4 指派问题

分配 n 个人去做 n 件工作，每人只做一件工作，每件工作只有一个人做，已知每个人做每件事的用时为c\_ij，如何安排才能使花费的总时间最少。

引入 0-1 变量 x\_ij：

$$
x_{i,j} = \begin{cases} 
0, & \text{第 } i \text{ 人不做第 } j \text{ 件工作} \\ 
1, & \text{第 } i \text{ 人做第 } j \text{ 件工作}, \; i, j = 1, \ldots, n 
\end{cases}
$$


指派问题的数学模型就可以描述为：

$$
\min f(x) = \sum_{i=1}^n \sum_{j=1}^n (c_{ij} x_{ij})
$$

$$
\text{s.t.:} \begin{cases} 
\sum_{j=1}^n x_{ij} = 1, & i = 1, \ldots, n \\ 
\sum_{i=1}^n x_{ij} = 1, & j = 1, \ldots, n \\ 
x_{ij} = 0, 1, & i, j = 1, \ldots, n 
\end{cases}
$$





在此基础上，还可以衍生出新的问题：

+   分配 m 个人去做 n 件工作，已知每个人做每件事的用时，当 m<n（不限定每人工作的件数）、m>n（不限定每件工作的参与人数）时，如何安排使花费的总时间最少。
+   分配 m 个人去做 n 件工作，已知每个人做每件事的用时，如果允许某人完成自己的工作后去帮助别人，如何安排使花费的总时间最少。

* * *

  

## 3\. 0-1 规划的求解方法

目前 0-1 规划问题并没有通用、高效、精确的求解方法，常用的方法或是针对特殊问题，或是近似方法。

需要特别指出的是，我们在数学建模的学习中会遇到越来越多的问题都没有通用、高效、精确的求解方法，而是借助于计算机算法和程序来得到近似解。

### 3.1 隐枚举法（Implicit enumeration）

求解 0-1 规划问题的思路，首先是穷举法，遍历决策变量的所有的组合，求出目标函数的最优值。随着问题规模的增大，变量的组合成指数增长，穷举法就不可能实现了。

隐枚举法是通过反复构造过滤条件，不断删除比当前解差的解集，并把优于当前最优解的结果作为新的最优解，再以新的最优解构造新的过滤条件，如此反复直到求出最优解。

隐枚举法通过过滤条件对穷举法进行改进，可以较快地求出最优解。分支定界法也是一种隐枚举法。

### 3.2 蒙特卡洛法（Monte Carlo）

既然对较大规模问题无法穷举，无法获得数学意义上的最优解，那么另一个思路就是随机搜索。于是大名鼎鼎、无所不能的蒙特卡洛法出场了。

蒙特卡洛法是一类随机方法的统称，也称随机取样法。顾名思义，蒙特卡洛法就是大量地对决策变量随机取值——如果能在满足约束条件的前提下随机取值就更好了，通过比较其目标函数值来不断获得更好的解，最后就能得到近似的最优解。

蒙特卡洛法的特点是，可以在随机采样上计算得到近似结果，采样越多，越近似最优解 ，但无法保证得到的结果是不是全局最优解。可以证明，在一定的计算量的情况下，蒙特卡洛法可以获得较好的满意解。

蒙特卡洛法的思想很简单，看起来算法也很简单，但实际上也涉及了深刻的数学理论，算法理论与实践也都在不断的发展。

蒙特卡洛法不仅可以处理几乎所有的决策问题、优化问题，而且在各种学科领域都得到了广泛的应用。这样的方法我们当然不能错过，后文将专题进行讨论。

### 3.3 启发式算法（Heuristic algorithms）

设计高效的启发式算法解决实际问题，是解决 0-1 规划问题的另一个思路。

启发式算法通常是以问题为导向的，没有一个通用的框架，根据具体问题的特殊结构来识别启发性信息，构造启发式优化过程来高效地寻找近似最优解。

启发式算法获得的近似最优解，通常是局部最优解。而且，启发式算法的解需要借助其他方法来评估其质量，并且在实际应用中不能保证为各种算例稳定地生成接近全局最优的可行解。

### 3.4 近似算法（Approximation algorithms）

本来不想在这里谈近似算法的，只是为了说明启发式算法并不是近似算法。

近似算法与启发式算法是不同的，近似算法往往通过巧妙的设计，得到的解是在全局最优解的某个邻域范围之内，或一定比例范围内。近似算法的解可以用严格的数学证明是“比较好”的，因而被认为是有保证的。

### 3.5 0-1 规划问题的编程方案

总结 0-1 规划的求解方法，就是没有通用、高效、精确的求解方法。

对于小白来说，其实这样更简单，不要操心学习哪种算法了，我们还是用 PuLP 工具包来求解。

* * *

  

## 4\. PuLP 求解 0-1 规划问题

不仅继续用 PuLP 工具包，而且解题过程和编程步骤也与求解线性规划问题完全一致。

下面我们以一个简单的数学模型练习，来讲解整个解题过程，而不仅给出例程。

### 4.1 案例问题描述

例题 1：  
公司有 5 个项目被列入投资计划，各项目的投资额和预期投资收益如下表所示（万元）：

| 项目     | A    | B    | C    | D    | E    |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 投资额   | 210  | 300  | 100  | 130  | 260  |
| 投资收益 | 150  | 210  | 60   | 80   | 180  |

公司只有 600万元资金可用于投资，综合考虑各方面因素，需要保证：

（1）项目 A、B、C 中必须且只能有一项被选中；  
（2）项目 C、D 中最多只能选中一项；  
（3）选择项目 E 的前提是项目 A被选中。

如何在上述条件下，进行投资决策，使收益最大。

  

### 4.2 建模过程分析

定义决策变量为：

xi\={0，不选择第i个项目1，选择第i个项目xi\={0，不选择第i个项目1，选择第i个项目x\_i = \\begin{cases} 0，不选择第\\;i\\;个项目\\\\ 1，选择第\\;i\\;个项目 \\end{cases}

定义目标函数为：

$$
\max f(x) = 150x_1 + 210x_2 + 60x_3 + 80x_4 + 180x_5
$$

$$
\text{s.t.:} \begin{cases} 
210x_1 + 300x_2 + 100x_3 + 130x_4 + 260x_5 \leq 600 \\ 
x_1 + x_2 + x_3 = 1 \\ 
x_3 + x_4 \leq 1 \\ 
x_5 \leq x_1 \\ 
x_i = 0, 1, & i = 1, \ldots, 5 
\end{cases}
$$





  

### 4.3 模型求解的编程

模型求解，用标准模型的优化算法对模型求解，得到优化结果。模型求解的编程步骤如下：

（0）导入 PuLP库函数

```haskell
    import pulp
```

（1）定义一个规划问题

```ini
     InvestLP = pulp.LpProblem("Invest decision problem", sense=pulp.LpMaximize)
```

pulp.LpProblem 用来定义问题的构造函数。"InvestLP"是用户定义的问题名。  
参数 sense 指定问题求目标函数的最小值/最大值 。本例求最大值，选择 “pulp.LpMaximize” 。

（2）定义决策变量  
对于问题 1：

```ini
    x1 = pulp.LpVariable('A', cat='Binary')  # 定义 x1，A 项目
    x2 = pulp.LpVariable('B', cat='Binary')  # 定义 x2，B 项目
    x3 = pulp.LpVariable('C', cat='Binary')  # 定义 x3，C 项目
    x4 = pulp.LpVariable('D', cat='Binary')  # 定义 x4，D 项目
    x5 = pulp.LpVariable('E', cat='Binary')  # 定义 x5，E 项目
```

pulp.LpVariable 用来定义决策变量的函数。'x1'~'x5' 是用户定义的变量名。  
参数 cat 用来设定变量类型，' Binary ' 表示0/1变量（用于0/1规划问题）。

（3）添加目标函数

```lisp
    InvestLP += (150*x1 + 210*x2 + 60*x3 + 80*x4 + 180*x5)  # 设置目标函数 f(x)
```

（4）添加约束条件

```bash
    InvestLP += (210*x1 + 300*x2 + 100*x3 + 130*x4 + 260*x5 <= 600)  # 不等式约束
    InvestLP += (x1 + x2 + x3 == 1)  # 等式约束
    InvestLP += (x3 + x4 <= 1)  # 不等式约束
    InvestLP += (x5 - x1 <= 0)  # 不等式约束
```

　　添加约束条件使用 "问题名 += 约束条件表达式" 格式。  
　　约束条件可以是等式约束或不等式约束，不等式约束可以是 小于等于 或 大于等于，分别使用关键字">="、"<="和"=="。

（5）求解

```bash
    InvestLP.solve()
    print(InvestLP.name)  # 输出求解状态
    print("Status youcans:", pulp.LpStatus[InvestLP.status])  # 输出求解状态
    for v in InvestLP.variables():
        print(v.name, "=", v.varValue)  # 输出每个变量的最优值
    print("Max f(x) =", pulp.value(InvestLP.objective))  # 输出最优解的目标函数值
```

solve() 是求解函数，可以对求解器、求解精度进行设置。

  

### 4.4 Python 例程

```python
# mathmodel06_v1.py
# Demo05 of mathematical modeling algorithm
# Solving 0-1 binary programming with PuLP.
# Copyright 2021 Youcans, XUPT
# Crated：2021-06-02
# Python小白的数学建模课 @ Youcans

import pulp      # 导入 pulp 库

# 主程序
def main():
    # 投资决策问题：
    # 公司现有 5个拟投资项目，根据投资额、投资收益和限制条件，问如何决策使收益最大。
    """
    问题建模：
        决策变量：
            x1～x5：0/1 变量，1 表示选择第 i 个项目， 0 表示不选择第 i 个项目
        目标函数：
            max fx = 150*x1 + 210*x2 + 60*x3 + 80*x4 + 180*x5
        约束条件：
            210*x1 + 300*x2 + 100*x3 + 130*x4 + 260*x5 <= 600
            x1 + x2 + x3 = 1
            x3 + x4 <= 1
            x5 <= x1
            x1,...,x5 = 0, 1
    """
    InvestLP = pulp.LpProblem("Invest decision problem", sense=pulp.LpMaximize)  # 定义问题，求最大值
    x1 = pulp.LpVariable('A', cat='Binary')  # 定义 x1，A 项目
    x2 = pulp.LpVariable('B', cat='Binary')  # 定义 x2，B 项目
    x3 = pulp.LpVariable('C', cat='Binary')  # 定义 x3，C 项目
    x4 = pulp.LpVariable('D', cat='Binary')  # 定义 x4，D 项目
    x5 = pulp.LpVariable('E', cat='Binary')  # 定义 x5，E 项目
    InvestLP += (150*x1 + 210*x2 + 60*x3 + 80*x4 + 180*x5)  # 设置目标函数 f(x)
    InvestLP += (210*x1 + 300*x2 + 100*x3 + 130*x4 + 260*x5 <= 600)  # 不等式约束
    InvestLP += (x1 + x2 + x3 == 1)  # 等式约束
    InvestLP += (x3 + x4 <= 1)  # 不等式约束
    InvestLP += (x5 - x1 <= 0)  # 不等式约束
    InvestLP.solve()  # youcans
    print(InvestLP.name)  # 输出求解状态
    print("Status youcans:", pulp.LpStatus[InvestLP.status])  # 输出求解状态
    for v in InvestLP.variables():
        print(v.name, "=", v.varValue)  # 输出每个变量的最优值
    print("Max f(x) =", pulp.value(InvestLP.objective))  # 输出最优解的目标函数值

    return

if __name__ == '__main__':  # Copyright 2021 YouCans, XUPT
    main()  # Python小白的数学建模课 @ Youcans
```

  

### 4.5 Python 例程运行结果

```makefile
Welcome to the CBC MILP Solver 
Version: 2.9.0 
Build Date: Feb 12 2015 

Result - Optimal solution found

Invest_decision_problem
Status youcans: Optimal
A = 1.0
B = 0.0
C = 0.0
D = 1.0
E = 1.0
Max f(x) = 410.0
```

从 0-1 规划模型的结果可知，选择 A、C、E 项目进行投资，可以满足限定条件并获得最大收益 410万元。

* * *

  

## 5\. 小结

1.  对于小白学数模，能识别哪些问题是 0-1 规划问题，是哪种 0-1规划问题，才能将问题描述转化为数学模型的表达形式。这是数模学习中最重要的内容。
2.  至于模型的求解，对于算法能了解一些最好，不求甚解也没关系，先学会用工具包解决问题就可以了。
3.  从线性规划、整数规划到本文的 0-1 规划，我们都选择了 PuLP 工具包。虽然这些问题的类型不同，求解算法差别非常大，但是 PuLp 工具包使用了一致的处理步骤：定义问题、定义变量、定义目标函数和约束条件，调用求解器求解。
4.  所以我们在求解不同问题时的编程方法和步骤如出一辙，完全感受不到不同类型问题之间的巨大差异。这就是为什么在线性规划问题时不选择 Scipy 的原因，这就是本系列课程的特点，让小白能快速入门求解问题。
5.  对于更为复杂的问题，PuLP 还提供了快捷方式，可以结合 Python语言的循环和容器，使用字典来创建问题，我们下节再讲。

**【本节完】**